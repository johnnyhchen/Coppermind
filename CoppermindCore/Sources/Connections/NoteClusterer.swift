// NoteClusterer.swift â€” DBSCAN clustering of notes by embedding similarity
// CoppermindCore

import Foundation

/// Clusters notes into NoteGroups using DBSCAN on their embeddings.
///
/// Auto-names groups from the top-3 TF-IDF keywords across member notes.
/// Preserves user-renamed groups (those where `autoGenerated == false` or
/// whose name was manually edited after creation).
public actor NoteClusterer {

    // MARK: - Configuration

    public struct Configuration: Sendable {
        /// DBSCAN: maximum cosine *distance* (1 - similarity) between neighbours.
        /// Lower values produce tighter clusters.
        public let eps: Double
        /// DBSCAN: minimum number of points to form a cluster.
        public let minPoints: Int

        public init(
            eps: Double = 0.4,
            minPoints: Int = 2
        ) {
            self.eps = eps
            self.minPoints = minPoints
        }
    }

    /// Result of a clustering run.
    public struct ClusterResult: Sendable {
        public let clusters: [Cluster]
        public let noise: [UUID]

        public init(clusters: [Cluster], noise: [UUID]) {
            self.clusters = clusters
            self.noise = noise
        }

        public struct Cluster: Sendable {
            public let centroid: [Float]
            public let noteIDs: [UUID]
            public let label: String?

            public init(centroid: [Float], noteIDs: [UUID], label: String?) {
                self.centroid = centroid
                self.noteIDs = noteIDs
                self.label = label
            }
        }
    }

    // MARK: - Dependencies

    private let embeddingService: EmbeddingService
    private let configuration: Configuration

    // MARK: - Init

    public init(
        embeddingService: EmbeddingService,
        configuration: Configuration = Configuration()
    ) {
        self.embeddingService = embeddingService
        self.configuration = configuration
    }

    // MARK: - Clustering

    /// Cluster notes by semantic similarity using DBSCAN.
    ///
    /// - Parameter notes: The notes to cluster.
    /// - Returns: Cluster assignments with centroids, labels, and noise point IDs.
    public func cluster(notes: [Note]) async throws -> ClusterResult {
        guard notes.count >= configuration.minPoints else {
            return ClusterResult(clusters: [], noise: notes.map(\.id))
        }

        // 1. Embed all notes
        let texts = notes.map { noteTextContent($0) }
        let embeddings = try await embeddingService.embedBatch(texts: texts)

        // 2. Precompute pairwise cosine distance matrix
        let n = embeddings.count
        var distMatrix = [[Double]](repeating: [Double](repeating: 0, count: n), count: n)
        for i in 0..<n {
            for j in (i + 1)..<n {
                let sim = await embeddingService.similarity(embeddings[i], embeddings[j])
                let dist = 1.0 - sim
                distMatrix[i][j] = dist
                distMatrix[j][i] = dist
            }
        }

        // 3. DBSCAN
        let labels = dbscan(distMatrix: distMatrix, eps: configuration.eps, minPoints: configuration.minPoints)

        // 4. Group by cluster label
        var clusterMap: [Int: [Int]] = [:]
        var noiseIndices: [Int] = []

        for (idx, label) in labels.enumerated() {
            if label == -1 {
                noiseIndices.append(idx)
            } else {
                clusterMap[label, default: []].append(idx)
            }
        }

        // 5. Build ClusterResult entries with centroids and TF-IDF labels
        let clusters: [ClusterResult.Cluster] = clusterMap.values.map { indices in
            let centroid = computeCentroid(indices: indices, embeddings: embeddings)
            let memberTexts = indices.map { texts[$0] }
            let topKeywords = TFIDFCalculator.topKeywords(from: memberTexts, topN: 3)
            let label = topKeywords.isEmpty ? nil : topKeywords.joined(separator: ", ")
            let noteIDs = indices.map { notes[$0].id }
            return ClusterResult.Cluster(centroid: centroid, noteIDs: noteIDs, label: label)
        }

        let noise = noiseIndices.map { notes[$0].id }
        return ClusterResult(clusters: clusters, noise: noise)
    }

    /// Convert ClusterResult into NoteGroup models, preserving user-renamed groups.
    ///
    /// - Parameters:
    ///   - result: Output of `cluster(notes:)`.
    ///   - notes: The same notes passed to `cluster`.
    ///   - existingGroups: Previously-persisted groups. If a group was renamed by
    ///     the user (`autoGenerated == false`) and its members still largely
    ///     overlap the new cluster, the existing name is preserved.
    /// - Returns: Array of NoteGroup models (new or updated).
    public func createGroups(
        from result: ClusterResult,
        notes: [Note],
        existingGroups: [NoteGroup] = []
    ) -> [NoteGroup] {
        let noteMap = Dictionary(uniqueKeysWithValues: notes.map { ($0.id, $0) })

        // Index existing user-renamed groups by their member IDs for matching.
        let userRenamedGroups: [(group: NoteGroup, memberIDs: Set<UUID>)] = existingGroups
            .filter { !$0.autoGenerated }
            .map { ($0, Set($0.notes.map(\.id))) }

        return result.clusters.enumerated().map { index, cluster in
            let memberNotes = cluster.noteIDs.compactMap { noteMap[$0] }
            let clusterIDs = Set(cluster.noteIDs)

            // Check if an existing user-renamed group substantially overlaps
            let matchedUserGroup = userRenamedGroups.first { pair in
                let overlap = pair.memberIDs.intersection(clusterIDs)
                let overlapRatio = Double(overlap.count) / Double(max(clusterIDs.count, 1))
                return overlapRatio >= 0.5
            }

            if let existing = matchedUserGroup {
                // Preserve the user's name; update membership and centroid
                existing.group.notes = memberNotes
                existing.group.setCentroidEmbedding(cluster.centroid)
                existing.group.touch()
                return existing.group
            }

            // Create a new auto-generated group
            let name = cluster.label ?? "Cluster \(index + 1)"
            let group = NoteGroup(
                name: name,
                autoGenerated: true,
                notes: memberNotes
            )
            group.setCentroidEmbedding(cluster.centroid)
            return group
        }
    }

    // MARK: - DBSCAN Implementation

    /// Standard DBSCAN algorithm operating on a precomputed distance matrix.
    ///
    /// - Parameters:
    ///   - distMatrix: NxN symmetric distance matrix.
    ///   - eps: Neighbourhood radius.
    ///   - minPoints: Minimum points for a core point.
    /// - Returns: Cluster labels per point. `-1` means noise.
    private func dbscan(distMatrix: [[Double]], eps: Double, minPoints: Int) -> [Int] {
        let n = distMatrix.count
        var labels = [Int](repeating: -2, count: n)  // -2 = undefined, -1 = noise
        var clusterID = 0

        for i in 0..<n {
            guard labels[i] == -2 else { continue }  // already processed

            let neighbours = regionQuery(distMatrix: distMatrix, point: i, eps: eps)

            if neighbours.count < minPoints {
                labels[i] = -1  // noise
                continue
            }

            // Start a new cluster
            labels[i] = clusterID
            var seed = neighbours
            seed.removeAll { $0 == i }

            var queue = seed
            while !queue.isEmpty {
                let q = queue.removeFirst()

                if labels[q] == -1 {
                    labels[q] = clusterID  // border point
                }
                guard labels[q] == -2 else { continue }  // already in a cluster

                labels[q] = clusterID
                let qNeighbours = regionQuery(distMatrix: distMatrix, point: q, eps: eps)

                if qNeighbours.count >= minPoints {
                    queue.append(contentsOf: qNeighbours.filter { labels[$0] == -2 || labels[$0] == -1 })
                }
            }

            clusterID += 1
        }

        // Convert remaining -2 (should not happen) to noise
        return labels.map { $0 == -2 ? -1 : $0 }
    }

    /// Find all points within `eps` distance of `point`.
    private func regionQuery(distMatrix: [[Double]], point: Int, eps: Double) -> [Int] {
        var result: [Int] = []
        for j in 0..<distMatrix[point].count {
            if distMatrix[point][j] <= eps {
                result.append(j)
            }
        }
        return result
    }

    // MARK: - Helpers

    /// Compute the mean (centroid) of a subset of embeddings.
    private func computeCentroid(indices: [Int], embeddings: [[Float]]) -> [Float] {
        guard let first = indices.first else { return [] }
        let dim = embeddings[first].count
        var sum = [Float](repeating: 0, count: dim)
        for idx in indices {
            for d in 0..<dim {
                sum[d] += embeddings[idx][d]
            }
        }
        let count = Float(indices.count)
        return sum.map { $0 / count }
    }

    /// Combine note title and body for embedding.
    private func noteTextContent(_ note: Note) -> String {
        [note.title, note.body].filter { !$0.isEmpty }.joined(separator: " ")
    }
}
